# -*- coding: utf-8 -*-
"""trihexAlternativeSignatures.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JxCcrxNM2RMu-LW7POuI6X0otkBWtIqi

Import libraries
"""

import csv
import matplotlib.pyplot as plt
import math

"""Solve equations mod n"""

def solveEquationModN(aa, rr, nn):
  # solve for the variable x in the equation a*x = r mod n, returning the smallest positive integer solutions, and return NULL if there is no solution
  for ii in range(1,nn+1):
    if (aa*ii % nn) == (rr % nn):
        return ii
  print("ERROR IN solveEquationModN")
  return NULL

def findOrder(aa, nn):
  # find the order of aa in Z_nn
  return solveEquationModN(aa, 0, nn)

def findAltSigs(n1, r1, k1):
  # given the signatture for a trihex (n1, r1, k1), find the two alteranative signatures
  j2 = findOrder(k1, n1 + 1)
  j3 = findOrder (k1 + r1 + 1, n1 + 1)
  n2 = j2*(r1 + 1) - 1
  n3 = j3*(r1 + 1) - 1
  h = 2*n1*r1 + 2*n1 + 2*r1
  r2 = int((h - 2*n2)/(2*n2 + 2))
  r3 = int((h - 2*n3)/(2*n3 + 2))
  #p_2, the smallest non-zero number such that p_2*k_1 = r_2 + 1 mod (n1 + 1)
  p2 = solveEquationModN(k1, r2 + 1, n1 +1)
  #print("p2: " + str(p2))
  k2 = (n2 - p2*(r1 + 1) - r2) % (n2 + 1)
  altSig2 = (n2, r2, k2)
  #p_3, the smallest non-zero number such that p_3*(k_1 + r_1 + 1) = r_3 + 1 mod (n_1 + 1)
  p3 = solveEquationModN(k1 + r1 + 1, r3 + 1, n1 + 1)
  #print("p3: " + str(p2))
  k3 = (n3 - p3*r1 - p3 + 1) % (n3 + 1)
  altSig3 = (n3, r3, k3)
  return altSig2, altSig3

def findMirrorSig(n1, r1, k1):
  # given the signature (n1, r1, k1) find one mirror image signature
  k2 = (n1 - r1 - k1) % (n1 + 1)
  return (n1, r1, k2)

def findAltSigsCollapseMirrors(n1, r1, k1):
  (alt2, alt3) = findAltSigs(n1, r1, k1)
  alt4 = findMirrorSig(n1, r1, k1)
  (alt5, alt6) = findAltSigs(alt4[0], alt4[1], alt4[2])
  return (alt2, alt3, alt4, alt5, alt6)

def sortAltSigs(n1, r1, k1):
  # find the signature with the lowest value of r. If there is a tie, use the lowest value of k also
  # however, it might make more sense to tie break using a value of k closest to either 0 or n, since
  # a value k = i is mirror symmetric to k = n - i
  (altSig2, altSig3) = findAltSigs(n1, r1, k1)
  allSigs = ((n1, r1, k1), altSig2, altSig3)
  sortedSigs = sorted(allSigs, key=lambda tup: (tup[1], tup[2]))
  return sortedSigs

def sortAltSigsCollapseMirrors(n1, r1, k1):
  # find the signature with the lowest value of r. If there is a tie, use the lowest value of k also
  # however, it might make more sense to tie break using a value of k closest to either 0 or n, since
  # a value k = i is mirror symmetric to k = n - i
  (altSig2, altSig3, altSig4, altSig5, altSig6) = findAltSigsCollapseMirrors(n1, r1, k1)
  allSigs = ((n1, r1, k1), altSig2, altSig3, altSig4, altSig5, altSig6)
  sortedSigs = sorted(allSigs, key=lambda tup: (tup[1], tup[2]))
  return sortedSigs

def numberOfHexagonsForSignature(nn, rr, kk):
  return 2*nn*rr + 2*nn + 2*rr

def printListOfAlternateSignatures(maxN, maxR):
  for ii in range(0,maxN):
    for jj in range(0, maxR):
      for kk in range(0, ii + 1):
        altSig1 = (ii, jj, kk)
        (altSig2, altSig3) = findAltSigs(ii, jj, kk)
        print(altSig1, altSig2, altSig3)
        print()

def storeCsvFileOfAlternateSignatures(maxN, maxR):
  with open('triHexSigs.csv', mode='w') as sig_file:
    sig_writer = csv.writer(sig_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    sig_writer.writerow(["n1", "r1", "k1", "n2", "r2", "k2", "n3", "r3", "k3"])
    for ii in range(0,maxN):
      for jj in range(0, maxR):
        for kk in range(0, ii + 1):
          altSig1 = (ii, jj, kk)
          (altSig2, altSig3) = findAltSigs(ii, jj, kk)
          sig_writer.writerow([ii, jj, kk, altSig2[0], altSig2[1], altSig2[2], altSig3[0], altSig3[1], altSig3[2]])

def storeCsvFileOfSortedAlternateSignatures(maxN, maxR):
  with open('triHexSigsSorted.csv', mode='w') as sig_file:
    sig_writer = csv.writer(sig_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    sig_writer.writerow(["n1", "r1", "k1", "n2", "r2", "k2", "n3", "r3", "k3"])
    for ii in range(0,maxN):
      for jj in range(0, maxR):
        for kk in range(0, ii + 1):
          altSig1 = (ii, jj, kk)
          #(altSig2, altSig3) = findAlternativeTrihexSignatures(ii, jj, kk)
          #sig_writer.writerow([ii, jj, kk, altSig2[0], altSig2[1], altSig2[2], altSig3[0], altSig3[1], altSig3[2]])
          ss = sortAltSigs(ii, jj, kk)
          if altSig1 == ss[1]:
            sig_writer.writerow([ss[0][0], ss[0][1], ss[0][2], ss[1][0], ss[1][1], ss[1][2], ss[2][0], ss[2][1], ss[2][2]])

storeCsvFileOfAlternateSignatures(11, 21)
storeCsvFileOfSortedAlternateSignatures(11, 21)

def getMinimalSig(n1, r1, k1):
  ss = sortAltSigs(n1, r1, k1)
  return ss[0]

def getMinimalSigCollapseMirrors(n1, r1, k1):
  ss = sortAltSigsCollapseMirrors(n1, r1, k1)
  return ss[0]

"""Find how many trihexes with each number of hexagons"""

def getSumOfFactors(x):
  y = get_divisors(x)
  mySum = 0
  for num in y:
    mySum = mySum + num
  return mySum

def get_divisors(n):
  listOfDivisors = []
  for i in range(1, int(n / 2) + 1):
    if n % i == 0:
      listOfDivisors.append(i)
  listOfDivisors.append(n)
  return listOfDivisors

def getSigsForGivenNumberOfHexes(hh):
  if hh % 2 == 1:
    return NULL
  listOfSigs = []
  for jj in get_divisors(int(hh/2) + 1):
    n1 = jj - 1
    r1 = int((hh/2 + 1)/jj - 1)
    for kk in range(n1+1):
       listOfSigs.append( (n1, r1, kk) )
  return listOfSigs

def getUniqueSigsForGivenNumberOfHexes(hh):
  if hh % 2 == 1:
    return []
  listOfSigs = []
  for jj in get_divisors(int(hh/2) + 1):
    n1 = jj - 1
    r1 = int((hh/2 + 1)/jj - 1)
    for kk in range(n1+1):
      if getMinimalSig(n1, r1, kk) == (n1, r1, kk):
        listOfSigs.append((n1, r1, kk))
  return listOfSigs

def getUniqueSigsCollapseMirrorsForGivenNumberOfHexes(hh):
  # signatures that are equivalent by mirror symmetry are considered the same
  if hh % 2 == 1:
    return []
  listOfSigs = []
  for jj in get_divisors(int(hh/2) + 1):
    n1 = jj - 1
    r1 = int((hh/2 + 1)/jj - 1)
    for kk in range(n1+1):
      if getMinimalSigCollapseMirrors(n1, r1, kk) == (n1, r1, kk):
        listOfSigs.append((n1, r1, kk))
  return listOfSigs

aa = getSigsForGivenNumberOfHexes(40)
len(aa)

bb = getUniqueSigsForGivenNumberOfHexes(40)
len(bb)

bb = getUniqueSigsCollapseMirrorsForGivenNumberOfHexes(40)
len(bb)

def listNumberOfTrihexesWithAtMostNumberOfHexes(hh):
  trihexCount = []
  for ii in range(hh+1):
    trihexCount.append(len(getUniqueSigsForGivenNumberOfHexes(ii)))
  return trihexCount

def listNumberOfTrihexesCollapseMirrorsWithAtMostNumberOfHexes(hh):
  trihexCount = []
  for ii in range(hh+1):
    trihexCount.append(len(getUniqueSigsCollapseMirrorsForGivenNumberOfHexes(ii)))
  return trihexCount

def listNumberOfTrihexesCollapseMirrorsNoGodseyesWithAtMostNumberOfHexes(hh):
  trihexCount = []
  for ii in range(hh+1):
      if (ii % 2 == 0):
        next = len(getUniqueSigsCollapseMirrorsForGivenNumberOfHexes(ii))-1
      else:
        next = 0
      trihexCount.append(next) # because exactly one is a godseye
  return trihexCount

listNumberOfTrihexesWithAtMostNumberOfHexes(10)

listNumberOfTrihexesCollapseMirrorsWithAtMostNumberOfHexes(10)

listNumberOfTrihexesCollapseMirrorsNoGodseyesWithAtMostNumberOfHexes(10)

zz = 200
# plot only for the even numbers of hexagons, which is vertices number that are multiples of 4
xx = range(zz+1)
vv = [0]*(zz+1)
for ii in xx:
  vv[ii] = 2*ii + 4

aa = listNumberOfTrihexesWithAtMostNumberOfHexes(zz)
bb = listNumberOfTrihexesCollapseMirrorsWithAtMostNumberOfHexes(zz)
yy = [getSumOfFactors(hexes/2 + 1) for hexes in xx]
ww = [num/3 for num in yy]
pp = [math.ceil(num/3) for num in yy]
ff = [num/6 for num in yy]
gg = [math.ceil(num/6) for num in yy]

plt.figure().set_figheight(6)
plt.plot(vv[0::2], aa[0::2], label = r'$\alpha(v)$')
plt.plot(vv[0::2], ww[0::2], label = r'$\sigma(v)/3$')
plt.plot(vv[0::2], bb[0::2], label = r'$\beta(v)$')
plt.plot(vv[0::2], ff[0::2], label = r'$\sigma(v)/6$')
plt.legend()
plt.xlabel("Vertices")
plt.ylabel("Counts")
plt.show()

deviant = 0
percentDeviant = 0
maxDeviant = 0
maxPercentGap = 0
foundItGap = 0
foundItPercentGap = 0
for ii in range(100, len(aa), 2):
  gap = aa[ii] - math.ceil(yy[ii]/3)
  percentGap = gap/math.ceil(yy[ii]/3)
  percentGap = gap/(yy[ii]/3)
  if (gap > 1):
    deviant  = deviant + 1
  if (percentGap > 0.1):
    percentDeviant  = percentDeviant + 1
  if (gap > maxDeviant):
    maxDeviant = gap
    foundItGap = ii
  if (percentGap > maxPercentGap):
    maxPercentGap = percentGap
    foundItPercentGap = ii
print("maxDeviant = ", maxDeviant)
print("fractionDeviant =", deviant/len(aa))
print("maxPercentGap =", maxPercentGap)
print("fractionPercentDeviant ", percentDeviant/len(aa))
print("locationOfMaxPercentGap  ", foundItPercentGap)
print("locationOfMaxGap  ", foundItGap)

deviant = 0
percentDeviant = 0
maxDeviant = 0
maxPercentGap = 0
foundItGap = 0
foundItPercentGap = 0
for ii in range(100, len(bb), 2):
  gap = bb[ii] - math.ceil(yy[ii]/6)
  percentGap = gap/math.ceil(yy[ii]/6)
  percentGap = gap/(yy[ii]/6)
  if (gap > 1):
    deviant  = deviant + 1
  if (percentGap > 0.1):
    percentDeviant  = percentDeviant + 1
  if (gap > maxDeviant):
    maxDeviant = gap
    foundItGap = ii
  if (percentGap > maxPercentGap):
    maxPercentGap = percentGap
    foundItPercentGap = ii
print("maxDeviant = ", maxDeviant)
print("fractionDeviant =", deviant/len(bb))
print("maxPercentGap =", maxPercentGap)
print("fractionPercentDeviant ", percentDeviant/len(bb))
print("locationOfMaxPercentGap  ", foundItPercentGap)
print("locationOfMaxGap  ", foundItGap)

for ii in range(0,(len(ww) + 1),2):
  print(ii, qq[ii], math.ceil(aa[ii]), aa[ii] - math.ceil(yy[ii]/3), bb[ii], math.ceil(yy[ii]/6), bb[ii] - math.ceil(yy[ii]/6))

def storeCsvFileOfCounts(alpha, beta, omega):
  with open('triHexCounts.csv', mode='w') as sig_file:
    sig_writer = csv.writer(sig_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    sig_writer.writerow(["h", "alpha", "omega/3", "beta", "omega/6"])
    for ii in range(0,len(alpha)):
      if (ii % 2  == 0):
        sig_writer.writerow([ii, alpha[ii], math.ceil(omega[ii]/3), beta[ii], math.ceil(omega[ii]/6)])

storeCsvFileOfCounts(aa, bb, yy)

weirdCurvatureSearch(200)